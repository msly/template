#include <windows.h>
#include "WinApplication.h"
#include <cassert>



typedef union
{
    ARGB Color;
    struct 
    {
        BYTE Blue;
        BYTE Green;
        BYTE Red;
        BYTE Alpha;
    };
}ARGBQuad, *PARGBQuad;

// 图像数据灰度化 二值化
void GrayAnd2Value(BitmapData *data, BYTE threshold)
{
    PARGBQuad p = (PARGBQuad)data->Scan0;
    int offset = data->Stride - data->Width * sizeof(ARGBQuad);

    for (UINT y=0; y<data->Height; ++y, p += offset)
    {
        for (UINT x=0; x<data->Width; ++x,++p)
        {
            if ( ((p->Blue * 29 + p->Green * 150 + p->Red * 77 + 128) >> 8) < threshold )
                p->Color &= 0xff000000;
            else
                p->Color |= 0x00ffffff;
        }
    }
}

void ShowImage(HDC hdc)
{
    Graphics graphics(hdc);
    Gdiplus::Bitmap bitmap(L"c:\\code.jpg");
    graphics.DrawImage(&bitmap, 10, 10);

    ColorMatrix clrMatrix = {
        0.3f,  0.3f,  0.3f,  0.0f, 0.0f,
        0.59f, 0.59f, 0.59f, 0.0f, 0.0f,
        0.11f, 0.11f, 0.11f, 0.0f, 0.0f,
        0.0f,  0.0f,  0.0f,  1.0f, 0.0f,
        0.0f,  0.0f,  0.0f,  0.0f, 1.0f
    };
    ImageAttributes ImgAttr;
    ImgAttr.SetColorMatrix(&clrMatrix);
    ImgAttr.SetThreshold(0.5);
    Graphics *g = Graphics::FromImage(&bitmap);
    g->DrawImage(&bitmap, GpRect(0, 0, bitmap.GetWidth(), bitmap.GetHeight()), 
        0, 0, bitmap.GetWidth(), bitmap.GetHeight(), UnitPixel, &ImgAttr);
    graphics.DrawImage(&bitmap, 10 + bitmap.GetWidth() + 2, 10);
}

void OnPaint(HDC hdc)
{
    Graphics graphics(hdc);
    Gdiplus::Bitmap bitmap(L".\\passCodeAction1.jpg");
    graphics.DrawImage(&bitmap, 10, 10);

    // 灰度化 二值化
    BitmapData bitmapData;
    Gdiplus::Rect r(0, 0, bitmap.GetWidth(), bitmap.GetHeight());
    bitmap.LockBits(&r, ImageLockModeRead | ImageLockModeWrite, PixelFormat32bppARGB, &bitmapData);
    PARGBQuad p = (PARGBQuad)bitmapData.Scan0;
    int offset = bitmapData.Stride - bitmapData.Width * sizeof(ARGBQuad);
    assert(offset == 0);
    int *zft = new int[bitmap.GetWidth()]();
    for (UINT y=0; y<bitmapData.Height; ++y, p += offset)
    {
        for (UINT x=0; x<bitmapData.Width; ++x,++p)
        {
            if ( ((p->Blue * 29 + p->Green * 150 + p->Red * 77 + 128) >> 8) < 128 )
            {
                p->Color &= 0xff000000;
                ++zft[x];
            }
            else
            {
                p->Color |= 0x00ffffff;
            }
        }
    }
    bitmap.UnlockBits(&bitmapData);

    Pen pen(Color(255, 0, 0, 255));
    for (int i=0; i<bitmap.GetWidth(); ++i)
    {
        graphics.DrawLine(&pen, 10+i, 10 + 2*bitmap.GetHeight(), 10+i, 10 + 2*bitmap.GetHeight() - zft[i]);
    }

    graphics.DrawImage(&bitmap,10 + bitmapData.Width + 2, 10);
}

INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, INT iCmdShow)
{
    CWinApplication WinApp(hInstance, iCmdShow);
    PaintProc = OnPaint;
    WinApp.Run();
    return 0;
} // WinMain
